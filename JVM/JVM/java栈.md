# 点此回到[[原理]]

## java栈也称为虚拟机栈、java方法栈

## Java栈是线程私有的，随着线程的生命周期而创建与销毁，每个线程都会创建一个虚拟机栈，每个java方法栈由多个**栈帧**（Stack Frame）组成，每个栈帧对应一次方法调用，所有对对象的引用都是在栈中

## 栈帧（Stack Frame），每个栈帧包含以下几个部分
- 局部变量表（Local Variable Table），类似数组
	- 用于存储**基本类型的变量数据**和**对象引用地址**，
	- 变量按索引（Slot）从0开始存储。对于实例方法，索引0通常是this引用，即args【】
	- 局部变量表的大小在编译时确定，不会在运行时改变
	- 变量可以是各种类型，如int、float、引用类型等，占不同索引位置
- 操作数栈（Operand Stack）
	- 用于执行字节码指令的操作数栈，类似于一个LIFO（后进先出）的数据结构
	- 在方法执行过程中存放中间计算结果以及临时数据
- 帧数据
	- 动态链接（Dynamic Linking）
		- 存储方法中的符号引用和直接引用之间的转换关系，用于支持运行时连接
		- 动态链接可以让方法调用更灵活，支持方法的重载和多态性，如常量池中的方法引用
	- 方法返回地址（Return Address）
		- 存储调用方法时的返回地址，当方法执行完毕后返回调用点，这部分在某些实现中可以在操作数栈中实现
- 附加信息（Additional Information），包括用于调试和异常处理的信息，例如，栈帧可能包含捕获异常的相关信息

## 栈帧工作原理：当一个线程调用一个方法时，JVM会创建一个新的栈帧并将其推入线程的Java栈顶。当方法执行完毕后，栈帧会被弹出，返回控制权给调用者。每个栈帧的生命周期严格按照方法调用的生命周期来管理。

## Java方法栈存在OutOfMenoryError，和StackOverflowError
- OutOfMenoryError，内存泄漏，指线程太多，导致内存不够
- StackOverflowError，方法调用层过多，栈帧叠多导致虚拟机占用内存空间溢出

## 栈帧的生命周期
- **创建**：每次方法调用时，JVM都会为该方法分配一个新的栈帧，并将其压入当前线程的Java栈顶
- **执行**：在方法执行过程中，局部变量表和操作数栈会不断地进行读写操作，当前栈帧可能会调用其他方法，此时JVM会为被调用方法创建一个新的栈帧并压入栈顶，当前栈帧执行完毕后，将返回调用方法的栈帧，并根据调用点继续执行
- **销毁**：方法执行完毕后，栈帧将从Java栈中弹出，返回调用方法的执行上下文

## 宏观讲，栈是特殊的线性表，只在表尾进行删除和插入操作
- 栈顶--top，，是表尾
- 栈底--vottom，，是表头
- 插入操作，Push，也叫进栈，压栈
- 删除操作，Pop，出栈，弹栈
- 销毁和清空是两个概念
