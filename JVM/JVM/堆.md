# 点此回到[[原理]]

## 堆（Heap）
- 在执行字节码指令时，所有**对象**和**数组**都应放在堆中，对象对应的**引用地址**存入虚拟机栈中的栈帧（局部变量表）中，在方法运行完后，对象不会被直接回收，要等JVM后台执行GC后才会回收对象
- 通过new一个字符串对象时，先去常量池查找是否有该对象，没有就先在常量池中创建对象，然后在堆中拷贝该对象
- **堆**和[[方法区]]一样是线程共享的，但是为了线程安全，必要时会使用同步机制
- 堆在JVM启动时创建，由垃圾收集器管理和回收

## 堆分为两个区域
- 年轻代（Young Generation）
	- **Eden区**：所有新对象首先分配在Eden区。当Eden区满时，会触发一次垃圾收集（Minor GC）。在Minor GC过程中，Eden区中仍然存活的对象将被移动到Survivor区，如果新对象大小超过了Eden区，则直接进入老年代
	- **Survivor区**：分为两个区域S0和S1（也叫from区和to区）。对象从Eden区移动到Survivor区，如果在后续的GC中仍然存活，会在S0和S1之间来回移动。当对象在Survivor区经历了一定次数的GC仍然存活，它们将被移动到老年代。
	- Eden区：S0：S1一般为8：1：1
- 老年代（Old Generation）
	- 存储生命周期较长的对象。老年代的垃圾收集频率较低，但每次回收时需要更多时间，通常发生在Full GC（整堆回收）和Major GC期间，CMS垃圾回收器是单独对老年代进行垃圾收集，其他则在整堆回收时，顺便把老年代回收
- 元空间（Metaspace）（在jdk8前是方法区，在jdk8后方法区变成了元空间）
	- 存储类的元数据（类定义、方法等）。在Java 8之前，这部分数据存储在堆的永久代（Permanent Generation）中。Java 8之后，元数据存储在本地内存中，称为元空间


## 新生代与老年代占比   -->  1:2
- 新生代占1/3
- 老年代2/3