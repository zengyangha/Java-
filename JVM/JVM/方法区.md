# 点此回到[[原理]]

## 功能和特点：
- 存储类中相关数据
- 是所有线程共享的区域，因此存储在方法区中的数据在所有线程之间是可见的，方法区和堆是共享的，在所有线程之间共享，方法区中的数据是线程安全的，JVM会确保在多个线程同时访问时的一致性
- 在程序开始运行时就会加载类的相关信息，在运行过程中可能动态加载新类
- 方法区的数据在类加载后直到类卸载时才会被释放
- 和[[堆]]区共享线程

## 方法区含有**常量池**，通常包括以下几个部分(作用)
- 存储每个类的结构信息，包括类元数据、常量池、静态变量和即时编译后的代码。方法区是规范中的一个逻辑概念，并不规定具体的实现方式
- 每个类都有一个常量池，用于存储编译时生成的各种字面量和符号引用，**字面量**：如字符串、整数、浮点数等，**符号引用**：如类名、方法名、字段名等，这些符号引用在类加载时解析为具体的内存地址或偏移量；有时可以存储**对象（字符串常量对象，如String）**
- 在常量池中如果存在
- 存储静态变量，字符串常量和基本类型常量（public static finally）
- 存储方法字节码
	- 方法区存储每个方法的字节码，这些字节码是在编译阶段生成的。当JVM执行某个方法时，它会从方法区读取该方法的字节码并解释或编译执行。
- 存储运行时常量池
	- 运行时常量池是方法区的一部分，用于存储运行时需要的常量，如方法和字段的符号引用。运行时常量池是每个类文件中的常量池表在类加载时解析后的结果
- 存储JIT编译后的本地代码
	- 即时编译器（Just-In-Time Compiler, JIT）会将热点代码（即频繁执行的代码）编译为本地机器码，并将这些机器码存储在方法区中。这样，后续执行时可以直接使用编译后的本地代码，提升执行效率。

## 方法区在不同JVM中的实现
- **HotSpot JVM**：方法区在Java 7及之前版本被称为永久代（Permanent Generation，简称PermGen）。在Java 8中，永久代被移除了，取而代之的是元空间（Metaspace），这是一块本地内存区域，用于存储类的元数据
- **其他JVM实现**：如JRockit和IBM J9等也有自己对方法区的实现，但基本原理和功能类似。


## Klass
- Klass是一个内部的类元数据结构，用于表示Java类和接口的元数据，方法区存储了类的元数据，而"Klass"结构是这些元数据的具体实现方式之一
- 在HotSpot JVM中，Klass是一个C++结构体，表示一个Java类的元数据。Klass结构存储了有关类的详细信息，例如类名、超类、接口、字段、方法等
- 每个Java类或接口在被加载时，JVM会创建一个对应的Klass对象，并将其存储在方法区中
- 简单类比：可以将方法区看作是一个存放书籍信息的图书馆，而Klass对象则是每本书的具体目录信息。图书馆（方法区）存放了很多书籍目录（Klass对象），每个目录详细描述了书籍的各种信息
- 方法区和Klass的关系：方法区用于存储类的元数据，而Klass是这些元数据的具体表示形式之一。换句话说，Klass对象是存储在方法区中的类元数据的具体实现
- 在Java 8之前，方法区在HotSpot JVM中被实现为永久代（PermGen），    从Java 8开始，永久代被移除了，取而代之的是元空间（Metaspace）。 元空间使用本地内存（Native Memory）来存储类的元数据，Klass对象依然是类元数据的表示形式，只是存储位置从永久代变为元空间。
	- 永久代（PermGen）是堆内存的一部分，大小是固定的，垃圾回收相对复杂，因为它涉及类的卸载和常量池的清理
	- 元空间（Metaspace）是JVM的一部分，使用的是本地内存（Native Memory），而不是堆内存，大小可以动态调整，默认情况下，元空间的大小仅受可用系统内存的限制，圾回收相对更高效，因为它利用了本地内存，并且在类卸载和常量池清理时表现更好。