# 点此回到[[原理]]

## 本地方法栈（Native Method Stack），是用来支持本地方法（native methods）执行的栈。这些本地方法通常是使用其他编程语言（例如C或C++）编写的，并通过Java本地接口（JNI, Java Native Interface）与Java代码进行交互。本地方法栈类似于Java栈（Java Stack），但是它专门用于处理本地方法的调用

## 与java方法栈的区别：
- 相同点：
	- 两者都用于存储方法调用过程中所需的数据，例如局部变量、操作数栈、动态链接信息和方法返回地址
	- 每个线程都有自己的Java方法栈和本地方法栈，这些栈在不同线程之间是独立的，不会相互影响。
	- 方法调用时，都会创建相应的栈帧，方法返回时，栈帧会被弹出和销毁
	- 两者的栈帧结构类似，都包含局部变量表、操作数栈、动态链接信息等
- 不同点：
	- 内存管理
		- VM自动管理，包括栈的分配和释放。开发者无需手动管理栈内存
		- 栈本身由JVM管理，但栈内执行的本地代码的内存管理需要开发者手动处理。例如，在C/C++中使用malloc/free或new/delete进行内存管理
	- 支持的语言不同
		- **java方法栈**：专门用于执行Java方法，支持Java语言
		- **本地方法栈**：用于执行非Java语言编写的本地方法，通常是C、C++等语言
	- 内存安全问题
		- JVM严格控制，保证了内存和类型的安全性，防止内存泄漏和非法内存访问。
		- 由于执行的是本地代码，本地方法栈可能存在安全隐患，例如缓冲区溢出、内存泄漏等问题。开发者需要自行确保本地代码的安全性
	- 异常处理
		- **ava方法栈**：支持Java的异常处理机制（try-catch-finally），并且可以抛出和捕获Java异常。
		- **本地方法栈**：需要使用JNI提供的异常处理API来处理Java异常，不能直接使用Java的异常机制
	- 方法调用和返回
		- **Java方法栈**：执行Java方法时，通过JVM的字节码解释器或JIT编译器来执行字节码，调用和返回都是通过JVM内部机制完成
		- **本地方法栈**：执行本地方法时，直接执行本地机器指令或本地库函数，调用和返回需要通过JNI来实现Java与本地代码之间的交互