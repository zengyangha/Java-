# 点此回到[[原理]]

## 根本作用：负责将Java字节码文件加载到JVM中，并在方法区中创建类的元数据结构

## 类加载过程分为以下三个主要阶段：
### 加载（Loading）
- **查找和加载类的二进制数据**：类加载器（ClassLoader）负责从文件系统、网络等不同来源 查找类的二进制数据。
- **将类的二进制数据加载到内存中**：将找到的二进制数据读取到内存中，并在方法区中创建一个 java.lang.Class 对象用于表示该类
- **验证类的正确性**：进行基本的文件格式检查。
### 链接（**Linking）**：
- **验证（Verification）**：确保类的字节码符合JVM规范
	- 文件格式：确保字节码文件的格式正确。
	- 元数据：确保类中的元数据 信息符合Java语言规范。
		- 类中的元数据信息指的是描述类、接口、方法、字段等编程元素的附加信息：类的基本信息，字段信息，方法信息，常量池，接口信息，属性和注解
	- 字节码：对方法体中的字节码进行数据流和控制流分析，确保没有非法的代码。
	- 符号引用：确保符号引用能在解析时正确解析。
- **准备（Preparation）**：为类的静态变量分配内存，并将其初始化为默认值（先是赋予0值）
- **解析（Resolution）**：将常量池中的符号引用转化为直接引用（如，将方法名解析为具体的方法地址,即真正的地址）
### 初始化（Initialization）
- 执行类构造器 《clinit》() 方法，对类的静态变量和静态代码块进行初始化（赋对应的值）

## 类加载器（ClassLoader）
- 类加载器是类加载子系统的核心组件，它们负责加载类的字节码，以下为JDK默认提供的，根本的不同是加载的目录不同
	- 启动类加载器（Bootstrap ClassLoader），是JVM的底层代码，c++写的，负责加载核心类库，是整个加载机制的根类加载器，如：rt.jar中的类
	- 扩展类加载器（Extension ClassLoader），负责加载jre/lib/ext目录下的类库或由系统变量java.ext.dirs指定的目录下的类库
	- 应用程序类加载器（Application ClassLoader），负责加载用户类路径（classpath）上的类库，是用户程序默认的类加载器
	- 可自定义加载类，以加载特定位置的类，如WebAppClassLoader，tomcat的自定义加载类，根本目的是实现类加载隔离

## 双亲委派模型
- 双亲委派模型（Parent Delegation Model）是Java类加载器实现的一种机制，用来保证Java核心类库的类型安全。通过这种机制（优点），Java程序运行时能够避免重复加载同一个类，并确保Java标准类库的类不会被自定义类库篡改
- 双亲委派模型的基本原理
	- 当一个类加载器收到类加载请求时，它不会自己先尝试去加载这个类，而是先将这个请求委派给父类加载器处理。只有当父类加载器无法完成类加载时，子类加载器才会尝试自己加载该类。
- 类加载器的层次结构，按照层次结构从上到下依次是：
	- 启动类加载器（Bootstrap ClassLoader）
	- 扩展类加载器（Extension ClassLoader）
	- 应用程序类加载器（Application ClassLoader）
- 工作过程,当一个类加载器（例如应用程序类加载器）尝试加载一个类时，具体过程如下：
	- 首先检查这个类是否已经加载过。如果加载过，直接返回已经加载的类
	- 如果没有加载过，先将类加载请求委派给父类加载器（例如，应用程序类加载器会将请求委派给扩展类加载器）
	- 父类加载器接收到请求后，同样会先检查这个类是否已经加载过，如果没有加载过，则继续向上委派，直到委派到启动类加载器
	- 启动类加载器会尝试加载这个类。如果它能够找到并加载这个类，就返回类对象,如果无法找到这个类，它会返回加载失败的信息
	- 父类加载器收到启动类加载器的加载失败信息后，会尝试自己加载这个类。如果加载失败，同样返回失败信息，依此类推
	- 最终，如果所有父类加载器都无法加载该类，子类加载器才会尝试自己加载该类
	- 因此防止核心类库（如`java.lang.Object`）被篡改，- - 所有加载请求最终都会先经过启动类加载器，确保加载到的是标准的JDK类库，同时同一个类在同一命名空间下只会被加载一次，避免了重复加载带来的开销和潜在的冲突



