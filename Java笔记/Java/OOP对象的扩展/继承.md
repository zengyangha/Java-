# 点此回到[[OOP对象]]

## 子类继承父类，is-a  关系，关键字：extends

## 超类、父类为父类，基类、子类、派生类为子类

## 狭义理解：
- 将两个类或多个类具有相同属性和方法时，可提取出来，放到特定的类里面变成父类，然后子类在继承

## 广义理解：
- 将重复代码放到父类中，子类可继承

## 所有java类都默认继承一个老祖宗类，叫Object，是所有类的根类

## 当子类继承父类后，创建子类对象时都会优先创建父类对象，然后再来执行子类的，以保证当创建子类后可以直接访问父类中的成员，默认情况下，实例化子类对象，不管是无参还是有参，默认都会先执行父类的无参构造函数，如果有意调用父类的有参构造，那就执行父类的有参构造函数

## 子类只能继承一个父类，java是单继承关系

## 子类想用父类的构造方法时，不是   继承(关系)  构造方法，而是调用，所以构造方法也不能重写

## 调用关键字：super
- super表示的是父类对象，是直接父类的引用
- 在创建对象时，可以在子类中直接通过super关键字调用父类的构造方法
- 也可以调用父类中被子类覆盖的方法   ：  super.父类方法名称和属性；
- 当super在构造方法中引用时，必须放第一位，且不能与this()方法同时存在
- 使用在属性上：表示访问父类的成员属性
- 使用在普通方法上：表示的是访问父类的成员方法

## 私有的不可继承

## 父类的static静态的属性和方法可以被调用，但是静态的方法不能被重写


## 父类可以为抽象类--[[常用类#抽象类-- 继承 99d8f3]]
- 关键字：abstract ^99d8f3
- 抽象类不能实例化，因此该构造函数没有意义，只能被子类调用
- 抽象类的抽象方法没有具体实现，即方法后面没有{}，如果抽象类的方法不是抽象方法，则可以包含具体实现即具体的普通方法，有方法体
- 抽象类不能直接实例化，但匿名内部类允许我们在创建抽象类的实例时同时提供具体实现，从而绕过直接实例化抽象类的限制
- 子类继承父类时，必须实现父类的抽象方法，或将子类的该方法也定义为抽象类
- 有抽象方法则必是抽象类，但抽象类不一定有抽象方法

## [[一些注意事项（较为重要）#方法重写（Override）]]