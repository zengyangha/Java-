# 点此回到[[（十分重要）集合框架（java容器,集合类）]]

- Collection（（接口）存放简单的API操作，存着一组   不唯一且  无序  的对象）
	- 特点：
		- 与数组不同的是可以存放不同数据类型，而数组只能放固定类型数据
		- 自动扩容
		- API具有（增、删、改）功能
	- List（接口）
		- （子类）存储着   不唯一，但有序（插入顺序）的对象，可用下标获取值
		- ArrayList和LinkedList的    底层数据结构不一样,都允许有空值null
		- ArrayList（底层数据结构是  数组  ）
			- 优点：遍历和随机访问速度快（查）
			- 缺点：添加和删除 速度慢（增删）
		- LinkedList（底层数据结构是  双向链表  ）
			- 优点：插入、删除快（增删）  （只需改变两指针即可，效率高，一个元素可视为Node单位）
			- 缺点：遍历和随机访问慢（查）
		- Stack(栈)  （日后再说）
		- Vector
			- 特点：
				- 和ArrayList一样底层数据结构为  数组
				- 有synchronized关键字，是线程安全的，速度比ArrayList慢，而ArrayList没有synchronized关键字，但速度快
				- Vector自动扩容是2倍，ArrayList是1.5倍
	- Set（接口）
		- （子类）存储着   唯一（元素不可重复），但无序，因无序而无法用下标获取值），HashSet允许存储null,而TreeSet不允许Null
		- 其唯一是比较引用地址和内容，当创建两个对象时，引用地址是不一样的，若内容一样，则会重复，重写equal和HashCode即可
		- HashSet （默认值为16，本质上是HashMap）
			- 特点：
				- 采用哈希表存储，具有随机性，以某一规则存储
				- 优点：增删查快
				- 缺点：有序，但不是传统的有序，本质还是无序，HashSet保持了基于哈希值的某种顺序，但没索引
				- 内部通过一个Hashmap实现，其元素被存储为HashMap的键，值则是固定的常量
				- 和Map关系还有是Map的键是唯一，HashSet是元素唯一
			- LinkedHashSet（子类，唯一且有序，该有序不是真正意义上有序，可预测的迭代顺序）
				- 采用哈希表存储，同时使用链表维护次序
				- 有序（添加顺序）
		- TreeSet   （（数据结构）本质是TreeMap，红黑树）
			- 数据结构为树
				- 树：（叶）类型必须一致
				- 树规定每个节点最多两个分支，左子树的分支值必须小于根节点，右子树的分支值必须大于根节点
			- 采用二叉树（红黑树、特殊平衡树（AVL机制，二分查找））的存储结构
			- 优点：有序（自动排序，排序后升序），实现了Comparable接口，重写了compareTo接口，所以可以自动排序，查询比List快，本质还是无序的，存入的顺序和取出的顺序是不一致的
			- 缺点：查询没有HashSet快
			- 如果存入的是对象，则会报错，因为存入的数据都要实现comparable接口的方法compareTo
			- 树中的元素是自动排序的，如果是基本数据类型，会自动比较，如果是引用类型（对象），则需要自定义比较器，比较名字长度或者数字大小亦或者是其他属性
				- 两种接口;
					- Comparable接口（内部比较器）
						- 所有可以排序的类都实现java.lang.Comparable接口,该接口只有一个实现方法
						- 定义在元素类中，通过重写compareTo()方法定义排序规则（需转换形参的引用类型）
					- Comparator接口（外部比较器）
						- 接口定义当前类中，通过实现Comparator接口后，在类中重写compare()方法，并设置规则，最后要将该比较器传递到集合中（我看到的是new一个该类，因为该类实现了Comparator接口，则该类变成了比较器的子类）
					- 内部比较类优势是可以随时使用，拿出即用
					- 外部比较类则是统一规定规则，其他元素类均可使用，这也是是工具类
					- 如果内部和外部比较器同时存在，则还是默认调用外部比较器
					- 使用比较器时，不会调用equal()方法