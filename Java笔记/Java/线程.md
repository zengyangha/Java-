# 点此回到[[JAVA（由此开始）]]

## 在java.lang.thread包中

## 程序是指令的集合，程序=数据结构+算法

## 进程：是程序的一次静态执行过程，占特定的地址空间，占用一个资源，进程间切换开销大，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位

## 线程：是进程中一个单一的连续控制流程，共享同一个空间，但抢占同一资源，线程间的通信是在同一地址空间上进行，可称为轻量级进程，进程间切换开销小


## Thread和Runnable的区别
- runnable容易实现资源共享
- 避免单继承的局限性
- 继承Thread的类不能放入线程池

## 并发与并行
- 并发：两个或以上的事件在同一个时间段内发生
- 并行：两个或以上的事件在同一时刻发生（同时发生）

## 进程是生成资源的最小单位，线程是进程的执行单元

## run（）为线程体，所有执行逻辑都在这里面，start（）为启动线程

## 实现多线程有两种
- 继承thread类
	- 重写run（）方法
	- 通过start（）启动
- 实现Runnable接口
	- 重写run方法
	- 创建thread对象，再将创建好的runnable的子类实现作为thread的构造参数
	- 通过thread.start（）启动，不然相当于一次普通的方法调用

## 使用实现Runnable接口时是使用了代理模式

## 线程状态（生命周期）：
- 有五种：创建（新生）--》就绪--》执行--》终止，，还有阻塞
- 新生状态：在创建线程对象后，没启动前；有自己的内存空间，但没有资源
- 就绪状态：具备运行条件，但没有资源（cpu），准备开始执行，但没有执行，表示在调用start方法后，所有线程添加到一个就绪的队列中，等待
- 执行状态：当进程获取资源后，就绪队列中所有线程抢占资源去执行，执行run方法过程为执行状态
- 死亡状态：1、线程正常运行后结束  2、抛出异常  3、人为中断stop方法
- 阻塞状态：
	- 等待阻塞：运行时遇到wait()方法，JVM将该线程放到等待池中
	- 锁阻塞状态：该线程尝试获取锁而该对象锁被占用，从而进入Blocked状态，会被JVM放入锁池中
	- 其他阻塞：进入方法有1、sleep方法或join方法   2、等待IO资源；3、程序运行时发生异常导致无法运行，当阻塞消除后，队列会重新回到就绪队列中等待抢占资源，4、人为的join()方法
![[线程状态生命周期.png]]


## 礼让（Thread.yield()方法），让当前线程礼让
- 礼让后从执行状态直接到就绪状态，不会进入阻塞状态，有可能刚好得到cpu的时间片，则礼让失败，如果下次没有获得时间片，则礼让成功


## 在多线程中，可以实现唤醒和等待过程，但该操作对应的表示线程，而是设置的共享对象或共享变量

## 线程安全问题：
- 前提
	- 1、有两个或以上线程
	- 2、多线程必须使用同一资源
	- 3、保证同步中只有一个线程运行
- 方法
	- 同步代码块，锁定一个监视对象（共享资源）
	- 同步方法

## 死锁：同步可以保证资源共享操作正确性，但过多的同步会产生死锁，比如小明有A，小红有B ，但小明想要B，而小红想要A，双方都不肯释放资源，这样会导致死锁

## 线程的消费者与生产者：生产者不断生产产品到一个区域中（共享资源），消费者不断从该区域获取产品，（相关类在JUC中，java.until.concurrent）

## Callable
- 与Runnable类似，但是Callable的call方法可以返回一个类型
- 支持抛出异常
- 支持泛型
- 创建CallAble对象后用FutureTask《》来接收，再用Thread执行start
- 返回值通过用FutureTask.get（）方法来接收

## Thread.sleep(),线程睡眠，让cpu不再执行这段时间，让其他线程获得执行权

## Join方法
- 在某个线程中，直接xx.join（），会调用**Thread的xx的线程**，直到xx的线程执行完毕，记得先启动线程，执行完该线程，会继续刚刚的线程，也可以join（10），只执行10毫秒，过了停止该线程

## 守护线程，执行时当所以用户线（非守护线程）程执行完后停止，但有时间差，通知信号有延迟，垃圾回收线程是典型的守护线程
- 只需要Thread的XX设置为XX.setDaemo(true);，即为守护线程

## sleep，让cup空闲，但不释放锁对象，用途
- sleep（100），让线程每0.1秒执行一次，控制执行节奏，同时让cpu的调用其他或者让cpu空闲，让其他线程可以有更多机会抢占cpu时间片
- 模拟延时
- sleep方法不能保证时间到后立即执行

## 线程优先级：
- 用Thread类的子类对象，xx.setPriority(1-10);

## 线程同步，synchronized，三个方法
- 同步代码块
	- synchronized(同步锁){  同步的代码  }
	- 同步锁可以是任意对象，也可以是当前类对象
- 同步方法
	- public synchronized void method(){ 同步内容  }
- 锁机制-显示锁
	- 创建锁对象  ReentrantLock lock =new ReentrantLock(true);
	- 在run方法中lock.lock();
	- 最后释放锁 lock.unlock();
	- 优势：
		- 支持非阻塞方式获取锁
		- 可响应中断
		- 可限时
		- 支持公平锁和非公平锁
			- 公平锁：先来先得，等待时间最长的线程优先获得锁，没有线程会长时间得不到锁，ReentrantLock(true)为公平锁
			- ReentrantLock()为默认非公平锁

## 线程等待wait（）
- 必须在synchronized中使用，使用时会释放锁，没锁会抛出异常
- 是Object类的方法，而sleep是Thread的方法
- 以同步锁来控制，Object.wait();
- wait(1000),等待1秒，时间到继续执行
- wait不是线程的操作，是多线程的通讯


## 唤醒线程notify（）
- wait和notify必须由同一个锁调用
- 以同步锁来控制，Object.notify();,   唤醒其他线程
- notifyAll（），唤醒当前锁对象的所有线程，但效率低





