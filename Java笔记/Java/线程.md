# 点此回到[[JAVA（由此开始）]]

## 在java.lang.thread包中

## 程序是指令的集合，程序=数据结构+算法

## 进程：是程序的一次静态执行过程，占特定的地址空间，占用一个资源，进程间切换开销大

## 线程：是进程中一个单一的连续控制流程，共享同一个空间，但抢占同一资源，线程间的通信是在同一地址空间上进行，可称为轻量级进程，进程间切换开销小

## 进程是生成资源的最小单位，线程是进程的执行单元

## run（）为线程体，所有执行逻辑都在这里面，start（）为启动线程

## 实现多线程有两种
- 继承thread类
	- 重写run（）方法
	- 通过start（）启动
- 实现Runnable接口
	- 重写run方法
	- 创建thread对象，再将创建好的runnable的子类实现作为thread的构造参数
	- 通过thread.start（）启动，不然相当于一次普通的方法调用

## 使用实现Runnable接口时是使用了代理模式

## 线程状态（生命周期）：
- 有五种：创建（新生）--》就绪--》执行--》终止，，还有阻塞
- 新生状态：在创建线程对象后，没启动前；有自己的内存空间，但没有资源
- 就绪状态：具备运行条件，但没有资源（cpu），准备开始执行，但没有执行，表示在调用start方法后，所有线程添加到一个就绪的队列中，等待
- 执行状态：当进程获取资源后，就绪队列中所有线程抢占资源去执行，执行run方法过程为执行状态
- 死亡状态：1、线程正常运行后结束  2、抛出异常  3、人为中断stop方法
- 阻塞状态：进入方法有1、sleep方法   2、等待IO资源；3、程序运行时发生异常导致无法运行，当阻塞消除后，队列会重新回到就绪队列中等待抢占资源，4、人为的join()方法


## 在多线程中，可以实现唤醒和等待过程，但该操作对应的表示线程，而是设置的共享对象或共享变量

## 线程安全问题：
- 前提
	- 1、有两个或以上线程
	- 2、多线程必须使用同一资源
	- 3、保证同步中只有一个线程运行
- 方法
	- 同步代码块，锁定一个监视对象（共享资源）
	- 同步方法

## 死锁：同步可以保证资源共享操作正确性，但过多的同步会产生死锁，比如小明有A，小红有B ，但小明想要B，而小红想要A，双方都不肯释放资源，这样会导致死锁

## 线程的消费者与生产者：生产者不断生产产品到一个区域中（共享资源），消费者不断从该区域获取产品，（相关类在JUC中，java.until.concurrent）

## Callable，与Runnable类似，但是Callable的call方法可以返回一个类型










