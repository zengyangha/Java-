# 点此回到[[JAVA（由此开始）]]

## 场景：当做一些集合的统一操作时，需要保证集合的类型是一致的，此时要泛型来限制

## 基本需求：给集合中的元素设置相同的类型，在定义对象时，使用<占位符>设置类型来实现

## 特点：
- 数据安全
- 获取数据效率高

## 泛型只在编译时起作用，编译后的字节码文件是没有泛型概念的，即JVM中没有泛型

## 高阶应用
- 泛型类
	- 就普通的泛型类，类名后面加《A》,A是占位符，在创建对象时再规定引用类型
- 泛型接口
	- 第一种形式：在接口名后加《B》,在对象类中实现泛型接口时，类名前要加《B》，这样该对象类用法普通泛型类一样了
	- 第二种形式：在接口名后加《B》,在对象类中实现泛型接口时，，类名前不加《B》，而在实现接口名后的《》中定义类型，在创建对象时就不再需要《》了，已经定义好类型了
- 泛型方法
	- 在对应泛型类中声明一个方法，此方法的返回类型前添加《Q》，该方法的形参中设置为《Q，q》，在新建对象使用时，可以使用任意类型，这样让泛型更丰富
- 泛型上限：如果父类确定了，所有子类都可以使用
- 泛型下线：如果子类确定了，子类的所有父类都可以直接传递参数使用


## 泛型在编译阶段作用，后面的字节码没有泛型概念

## 不能使用泛型的四种情况
- 不能使用在静态变量上
- 不能在静态方法上，但是静态的泛型方法可以，即普通静态方法的参数不能有泛型
- 不能在静态代码块上
- 不能在instanceof后面，因为instanceof后面是具体类型


## 为了保证数据安全，不允许多个数据类型的修改操作，但可以使用遍历操作，method（? extend Object），method(ArrayList《？》 a，ArrayList《？》 b )

## 泛型的上限和下限
- 上限
	- 传的数据类型是该类型或者该类型的子类，目前我见过两种，一种是在类中定义为泛型类calss（T extends  父类），然后创建该实例并调用方法，另一种是在一个普通类中创建方法method(List《? extend 父类》 list){}，
- 下限
	- 传的数据类型是该类型或者该类型的父类，和上限同理，不过将extends换为super